[
["RF.html", "Chapter 9 Random Forests 9.1 Prerequisites 9.2 Decision trees 9.3 Bagging 9.4 Random forests 9.5 Fitting a basic random forest model 9.6 Tuning 9.7 Feature interpretation 9.8 Attrition data 9.9 Final thoughts 9.10 Learning more", " Chapter 9 Random Forests The previous chapters covered models where the algorithm is based on a linear expansions in simple basis functions of the form \\(\\sum_{i=1}^p\\beta_ih_i\\left(\\boldsymbol{x}\\right)\\), where the \\(\\beta_i\\) are unknown coefficients to be estimated and the \\(h_i\\left(\\cdot\\right)\\) are transformations applied to the features \\(\\boldsymbol{x}\\). For ordinalry linear regression (with or without regularization), these transformations are supplied by the user; hence, these are parametric models. For example, the prediction equation \\(f\\left(\\boldsymbol{x}\\right) = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\beta_3x_1x_2 + \\beta_4x_1^2\\) has \\[h_1\\left(\\boldsymbol{x}\\right) = x_1 \\quad \\text{(main effect})\\] \\[h_2\\left(\\boldsymbol{x}\\right) = x_2 \\quad \\text{(main effect})\\] \\[h_3\\left(\\boldsymbol{x}\\right) = x_2x_4 \\quad \\text{(two-way interaction effect)}\\] \\[h_2\\left(\\boldsymbol{x}\\right) = x_2^2 \\quad \\text{(quadratic effect})\\] MARS, on the other hand, uses a specific algorithm to find the transformations to use automatically; hence, MARS is a nonparametric model. Tree-based models, are also nonparametric, but they work very differently. Tree-based models use algorithms to partition the feature space into a number of smaller (non-overlapping) regions based on a set of splitting rules and then fits a simpler model (e.g., a constant) in each region. Such divide-and-conquor methods (e.g., a single decision tree) can produce simple rules that are easy to interpret and visualize (e.g., with a tree diagram). Although fitted tree-based models can still be written as a linear expansions in simple basis functions (here the basis functions define the feature space partitioning), there is no benfit to doing so as other techniques, like tree diagrams, are better and conveying the information. Simple decision trees typically lack in predictive performance compared to more complex algorithms like neural networks and MARS. More sophisticated tree-based models, such as random forests and gradient boosting machines, are less interpretable, but tend to have very good predictive accuracy. This chapter will get you familiar with the basics behind decision trees, and two ways inwhich to combine them into a more accurate ensemble; namely, bagging and random forests. In the next chapter, we’ll cover (stochastic) gradient boosting machines, which is another powerful way of combining decision trees into a more accurate ensemble. 9.1 Prerequisites For this chapter we’ll use the following packages: library(caret) # for classification and regression training library(randomForest) # for Breiman and Cutler&#39;s random forest library(ranger) # for fast implementation of random forests library(rpart) # for fitting CART-like decision trees library(rpart.plot) # for flexible decision tree diagrams library(rsample) # for data splitting library(pdp) # for partial dependence plots library(vip) # for variable importance plots To illustrate the various concepts we’ll use the Ames Housing data (regression); however, at the end of the chapter we’ll also apply fit a random forest model to the employee attrition data (classification). # Create training (70%) and test (30%) sets for the AmesHousing::make_ames() data. # Use set.seed for reproducibility set.seed(123) ames_split &lt;- initial_split(AmesHousing::make_ames(), prop = .7) ames_train &lt;- training(ames_split) ames_test &lt;- testing(ames_split) 9.2 Decision trees There are many methodologies for constructing decision trees but the most well-known is the classification and regression tree (CART©) algorithm proposed in Breiman (1984). Basic decision trees partition the training data into homogenious subgroups and then fit a simple constant in each (e.g., the mean of the within group response values for regression). The partitioning is achieved by recursive binary partitions formed by asking yes-or-no questions about each feature (e.g., is age &lt; 18?). This is done a number of times until a suitable stopping critera is satiscfied (e.g., a maximum depth of the tree is reached). After all the partitioning has been done, the model predicts the output based on (1) the average response values for all observations that fall in that subgroup (regression problem), or (2) the class that has majority representation (classification problem). For classification, predicted probabilites can be obtained using the proportion of each class within the subgroups. The basic idea behind decision trees is to ask simple yes-or-no questions about each feature in order partion the training data into subgroups with similar response rates. Ideally, the repsonses within each subgroup will be as similar or homegenous as possible, while responses across subgroups will be as different or as heterogenous as possible. 9.2.1 A simple regression tree example For example, suppose we want to use a decision tree to predict the miles per gallon a car will average (mpg) based on two features: the number of cylinders (cyl) and the horsepower (hp); such data are available in the mtcars data frame which is part of the standard datasets package. A (regression) tree is built using the rpart package (Therneau and Atkinson 2018) (see the code chunk below and Figure ?? which was produced using the rpart.plot package (Milborrow 2018)), and all the training data are passed down this tree. Whenever an obervation reaches a partiular node in the tree (i.e., a yes-or-no question about one of the features; in this case, cyl or hp), it proceeds either to the left (if the answer is “yes”) or to the right (if the answer is “no”). This tree has only three terminal nodes. To start traversing the tree, all observations that have 6 or 8 cylinders go to the left branch, all other observations proceed to the right branch. Next, the left branch is further partitioned by hp. Of all the observations with 6 or 8 cylinders with hp equal to or greater than 192 proceed to the left branch; those with less than 192 hp proceed to the right. These branches lead to terminal nodes or leafs which contain the predicted response value; in this case, the average mpg of cars that fall within that terminal node. In short, cars with less than 5 cylinders (region \\(R_1\\)) average 27 mpg, cars with cyl \\(\\ge 5\\) and hp \\(&lt; 193\\) (region \\(R_2\\)) average 18 mpg, and all other cars (region \\(R_3\\)) in the training data average 13 mph. tree &lt;- rpart(mpg ~ cyl + hp, data = mtcars) # CART-like regression tree rpart.plot(tree) # tree diagram Figure 9.1: Using a CART-like decision tree to predict mpg based on cyl and hp. This simple example can be generalized as follows. We have a given response variable \\(Y\\) and two inputs \\(X_1\\) and \\(X_2\\). The recursive partitioning results in three non-verlapping regions denoted \\(R_1\\), \\(R_2\\), and \\(R_3\\). In region \\(R_m\\) \\(\\left(m = 1, 2, 3\\right)\\), the model predicts Y with a constant \\(c_m\\): FIXME: This doesn’t seem right? \\[\\begin{equation} \\widehat{f}\\left(X_1, X_2\\right) = \\sum^3_{m=1} c_m I{\\left(X_1, X_2 \\in R_m\\right)}. \\end{equation}\\] However, an the question remains of how to grow a decision tree; that is, select the partioning to give regions \\(R_j\\) for \\(j = 1, 2, \\dots\\). 9.2.2 Deciding on splits FIXME: Continue with the previous example? First, it’s important to realize that the partitioning of the feature space is done in a top-down, greedy fashion. This means that a any partion in the tree dpeends on the previous partitions. But how are these partions made? The algorithm begins with the entire training data set S and searches every distinct value of every input variable to find the “best” feature/split combination that partitions the data into two regions (\\(R_1\\) and \\(R_2\\)) such that the overall error is minimized (typically, MSE for regression problems, and cross-entropy or the Gini index for classification problems–see Section 4.7.7). Having found the best feature/split combination, the data are partitioned into two regions and the splitting process is repeated on each of the two regions. This process is continued until some stopping criterion is reached (e.g., a mxaimu depth is reached or the tree becomes “too complex”). What results is, typically, a very deep, complex tree that may produce good predictions on the training set, but is likely to generalize well to new unseen data (i.e., overfitting), leading to poor generalization performance. For example, using the well-known Boston housing data (Harrison Jr and Rubinfeld 1978), three decision trees are created based on three different samples of the data. You can see that the first few partitions are fairly similar at the top of each tree; however, they tend to differ substantially closer to the terminal nodes. These deeper nodes tend to overfit to specific attributes of the training data; consequently, slightly different samples will result in highly variable predicted values in the terminal nodes. For this reason, CART-like decision tree algorithms are often considered high variance (i.e., noisy) models fitting procedures. FIXME: Brad, can we replace this with the code that produced the results; either hidden or shown? Figure 9.2: Three decision trees based on slightly different samples. 9.3 Bagging Although pruning the tree helps reduce the variance1 of a single tree (i.e., by helping to avoid overfitting), there are alternative methods that exploit this variance in a way that can significantly improve performance over and above that of single trees. Bootstrap aggregating (bagging) (Breiman 1996) is one such approach. Bagging combines and averages multiple models.2 Averaging across multiple trees reduces the variability of any one tree and reduces overfitting, which improves predictive performance. Bagging follows three simple steps: Create m bootstrap samples (Section 3.6) from the training data. Bootstrapped samples allow us to create many slightly different data sets but with the same distribution as the overall training set. For each bootstrap sample, train a single, unpruned decision tree. Average individual predictions from each tree to create an overall average predicted value. Figure 9.3: The bagging process. This process can actually be applied to any regression or classification model; however, it provides the greatest improvement for models that have high variance. For example, more stable parametric models such as linear regression and multi-adaptive regression splines tend to experience less improvement in predictive performance when bagging. Although bagging trees can help reduce the variance of a single tree’s prediction and improve predictive performance, the trees in bagging are not completely independent of each other since all the original predictors are considered at every split of every tree. Rather, trees from different bootstrap samples typically have similar structure to each other (especially at the top of the tree) due to underlying relationships. For example, if we create six decision trees with different bootstrapped samples of the Boston housing data, we see that the top of the trees all have a very similar structure. Although there are 15 predictor variables to split on, all six trees have both lstat and rm variables driving the first few splits. Figure 9.4: Six decision trees based on different bootstrap samples. This characteristic is known as tree correlation and prevents bagging from optimally reducing variance of the predicted values. In order to reduce variance further, we need to minimize the amount of correlation between the trees. 9.4 Random forests Random forests are an extension of bagging and injects more randomness into the tree-growing process. Random forests achieve this in two ways: Bootstrap: similar to bagging, each tree is grown to a bootstrap resampled data set, which makes them different and somewhat decorrelates them. Split-variable randomization: each time a split is to be performed, the search for the split variable is limited to a random subset of m of the p variables. Typical default values for \\(m\\) are \\(m = \\frac{p}{3}\\) (regression problems) and \\(m = \\sqrt{p}\\) for classification models. However, this should be considered a tuning parameter. When \\(m = p\\), the randomization amounts to using only step 1 and is the same as bagging. The basic algorithm for a random forest model can be generalized to the following: 1. Given training data set 2. Select number of trees to build (ntrees) 3. for i = 1 to ntrees do 4. | Generate a bootstrap sample of the original data 5. | Grow a regression or classification tree to the bootstrapped data 6. | for each split do 7. | | Select m variables at random from all p variables 8. | | Pick the best variable/split-point among the m 9. | | Split the node into two child nodes 10. | end 11. | Use typical tree model stopping criteria to determine when a tree is complete (but do not prune) 12. end Since the algorithm randomly selects a bootstrap sample to train on and predictors to use at each split, tree correlation will be lessened beyond bagged trees. 9.4.1 OOB error vs. test set error One benefit of bagging (and thus also random forests) is that, on average, a bootstrap sample will contain 63% of the training data. This leaves about 37% of the data out of the bootstrapped sample. We call this the out-of-bag (OOB) sample. We can use the OOB observations to estimate the model’s accuracy, creating a natural cross-validation process, which allows you to not need to sacrifice any of your training data to use for validation. This makes identifying the number of trees required to stablize the error rate during tuning more efficient; however, as illustrated below some difference between the OOB error and test error are expected. Figure 9.5: Random forest out-of-bag error versus validation error. Furthermore, many packages do not keep track of which observations were part of the OOB sample for a given tree and which were not. If you are comparing multiple models to one-another, you’d want to score each on the same validation set to compare performance. Also, although technically it is possible to compute certain metrics such as root mean squared logarithmic error (RMSLE) on the OOB sample, it is not built in to all packages. So if you are looking to compare multiple models or use a slightly less traditional loss function you will likely want to still perform cross validation. 9.5 Fitting a basic random forest model There are over 20 random forest packages in R.3 To demonstrate the basic implementation we illustrate the use of the randomForest package (Breiman et al. 2018), the oldest and most well known implementation of the Random Forest algorithm in R. However, as your data set grows in size randomForest does not scale well (although you can parallelize with foreach). randomForest() can use the formula or separate x, y matrix notation for specifying our model. Below we apply the default randomForest model using the formulaic specification. The default random forest performs 500 trees and \\(\\frac{features}{3} = 26\\) randomly selected predictor variables at each split. Averaging across all 500 trees provides an OOB \\(MSE = 661089658\\) (\\(RMSE = \\$25,711\\)). # for reproduciblity set.seed(123) # default RF model rf1 &lt;- randomForest( formula = Sale_Price ~ ., data = ames_train ) rf1 ## ## Call: ## randomForest(formula = Sale_Price ~ ., data = ames_train) ## Type of random forest: regression ## Number of trees: 500 ## No. of variables tried at each split: 26 ## ## Mean of squared residuals: 661089658 ## % Var explained: 89.8 Plotting the model will illustrate the OOB error rate as we average across more trees and shows that our error rate stabalizes with around 100 trees but continues to decrease slowly until around 300 or so trees. plot(rf1) Figure 9.6: OOB error (MSE) as a function of the number of trees. We see the MSE reduces quickly for the first 100 trees and then slowly thereafter. We want to make sure that we are providing enough trees so that our OOB error has stabalized or flatlined. The plotted error rate above is based on the OOB sample error and can be accessed directly at rf1$mse. Thus, we can find which number of trees provides the lowest error rate, which is 447 trees providing an average home sales price error of $25,649. # number of trees with lowest MSE which.min(rf1$mse) ## [1] 447 # RMSE of this optimal random forest sqrt(rf1$mse[which.min(rf1$mse)]) ## [1] 25648.78 Random forests are one of the best “out-of-the-box” machine learning algorithms. They typically perform remarkably well with very little tuning required. As illustrated above, we were able to get an RMSE of $25,649 without any tuning which is nearly as good as the best, fully tuned model we’ve explored thus far. However, we can still seek improvement by tuning hyperparameters in our random forest model. 9.6 Tuning Compared to the algorithms explored in the previous chapters, random forests have more hyperparameters to tune. However, compared to gradient boosting machines and neural networks, which we explore in future chapters, random forests are much easier to tune. Typically, the primary concern when starting out is tuning the number of candidate variables to select from at each split. The two primary tuning parameters you should always tune in a random forest model are: Number of trees as you want to ensure you apply enough trees to minimize and stabalize the error rate. Number of candidate variables to select from at each split. However, there are a few additional hyperparameters that we should be aware of. Although the argument names may differ across packages, these hyperparameters should be present: Number of trees: We want enough trees to stabalize the error but using too many trees is unncessarily inefficient, especially when using large data sets. Number of variables to randomly sample as candidates at each split: Commonly referred to as “mtry”. When mtry \\(=p\\) the model equates to bagging. When mtry \\(=1\\) the split variable is completely random, so all variables get a chance but can lead to overly biased results. A common suggestion is to start with 5 values evenly spaced across the range from 2 to p. Sample size to train on: The default value is 63.25% of the training set since this is the expected value of unique observations in the bootstrap sample. Lower sample sizes can reduce the training time but may introduce more bias than necessary. Increasing the sample size can increase performance but at the risk of overfitting because it introduces more variance. Typically, when tuning this parameter we stay near the 60-80% range. Minimum number of samples within the terminal nodes: Controls the complexity of the trees. Smaller node size allows for deeper, more complex trees and larger node size results in shallower trees. This is another bias-variance tradeoff where deeper trees introduce more variance (risk of overfitting) and shallower trees introduce more bias (risk of not fully capturing unique patters and relatonships in the data). Maximum number of terminal nodes: Another way to control the complexity of the trees. More nodes equates to deeper, more complex trees and less nodes result in shallower trees. Split rule:As stated in the introduction, the most traditional splitting rules are based on minimizing the variance or MSE across the terminal nodes for regression problems and Cross-entropy or Gini index for classification problems. However, additional splitrules have been developed that can offer improved predictive accuracy. For example, the extra trees split rule chooses cut-points fully at random and uses the whole learning sample (rather than a bootstrap replica) to grow the trees (Geurts, Ernst, and Wehenkel 2006). Tuning a larger set of hyperparameters requires a larger grid search than we’ve performed thus far. Unfortunately, this is where randomForest becomes quite inefficient since it does not scale well. Instead, we can use ranger (Wright, Wager, and Probst 2018) which is a C++ implementation of Brieman’s random forest algorithm and, as the following illustrates, is over 27 times faster than randomForest. # names of features features &lt;- setdiff(names(ames_train), &quot;Sale_Price&quot;) # randomForest speed system.time( ames_randomForest &lt;- randomForest( formula = Sale_Price ~ ., data = ames_train, ntree = 500, mtry = floor(length(features) / 3) ) ) ## user system elapsed ## 35.321 0.157 35.487 # ranger speed system.time( ames_ranger &lt;- ranger( formula = Sale_Price ~ ., data = ames_train, num.trees = 500, mtry = floor(length(features) / 3) ) ) ## user system elapsed ## 7.009 0.132 1.087 9.6.1 Tuning via ranger There are two approaches to tuning a ranger model. The first is to tune ranger manually using a for loop. To perform a manual grid search, first we want to construct our grid of hyperparameters. We’re going to search across 48 different models with varying mtry, minimum node size, sample size, and trying different split rules. # create a tuning grid hyper_grid &lt;- expand.grid( mtry = seq(20, 35, by = 5), min.node.size = seq(3, 9, by = 3), sample.fraction = c(.632, .80), splitrule = c(&quot;variance&quot;, &quot;extratrees&quot;), OOB_RMSE = 0 ) dim(hyper_grid) ## [1] 48 5 We loop through each hyperparameter combination and apply 500 trees since our previous examples illustrated that 500 was plenty to achieve a stable error rate. Also note that we set the random number generator seed. This allows us to consistently sample the same observations for each sample size and make it more clear the impact that each change makes. Our OOB RMSE ranges between ~25,900-28,500. Our top 10 performing models all have RMSE values right around 26,000 and the results show that models with larger sample sizes (80%) and a variance splitrule perform best. However, no definitive evidence suggests that certain values of mtry or min.node.size are better than other values. This grid search took 69 seconds to complete. for(i in seq_len(nrow(hyper_grid))) { # train model model &lt;- ranger( formula = Sale_Price ~ ., data = ames_train, num.trees = 500, mtry = hyper_grid$mtry[i], min.node.size = hyper_grid$min.node.size[i], sample.fraction = hyper_grid$sample.fraction[i], splitrule = hyper_grid$splitrule[i], seed = 123 ) # add OOB error to grid hyper_grid$OOB_RMSE[i] &lt;- sqrt(model$prediction.error) } hyper_grid %&gt;% dplyr::arrange(OOB_RMSE) %&gt;% head(10) ## mtry min.node.size sample.fraction splitrule OOB_RMSE ## 1 20 3 0.8 variance 25963.96 ## 2 25 3 0.8 variance 25981.28 ## 3 20 6 0.8 variance 25981.66 ## 4 20 9 0.8 variance 26091.08 ## 5 30 3 0.8 variance 26123.07 ## 6 25 6 0.8 variance 26145.15 ## 7 30 6 0.8 variance 26167.42 ## 8 35 3 0.8 variance 26175.66 ## 9 35 6 0.8 variance 26189.23 ## 10 25 9 0.8 variance 26210.44 However, using this approach does not provide us with a cross validated measure of error. To get a k-fold CV error, we would have to expand our for loop approach or use an alternative approach. One such approach follows. 9.6.2 Tuning via caret The second tuning approach is to use the caret package. caret only allows you to tune some, not all, of the available ranger hyperparameters (mtry, splitrule, min.node.size). However, caret will allow us to get a CV measure of error to compare to our previous models (i.e. regularized regression, MARS). The following creates a similar tuning grid as before but with only those hyperparameters that caret will accept. If you do not know what hyperparameters caret allows you to tune for a specific model you can find that info at https://topepo.github.io/caret/train-models-by-tag.html or with caret::getModelInfo. For example, we can find the parameters available for a ranger with caret::getModelInfo(“ranger”)\\(ranger\\)parameter. # create a tuning grid hyper_grid &lt;- expand.grid( mtry = seq(20, 35, by = 5), min.node.size = seq(3, 9, by = 3), splitrule = c(&quot;variance&quot;, &quot;extratrees&quot;) ) Tuning with caret provides similar results as our ranger grid search. Both results suggest mtry = 20 and min.node.size = 3. With ranger, our OOB RMSE was 25963.96 and with caret our 10-fold CV RMSE was 25531.47. This grid search took a little over 6 minutes to complete. # cross validated model tuned_rf &lt;- train( x = subset(ames_train, select = -Sale_Price), y = ames_train$Sale_Price, method = &quot;ranger&quot;, metric = &quot;RMSE&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10), tuneGrid = hyper_grid, num.trees = 500, seed = 123 ) # best model tuned_rf$bestTune ## mtry splitrule min.node.size ## 7 25 variance 3 # plot results ggplot(tuned_rf) Figure 9.7: Cross validated RMSE for the caret grid search. 9.7 Feature interpretation Whereas many of the linear models discussed previously use the standardized coefficients to signal importance, random forests have, historically, applied two different approaches to measure variable importance. Impurity: At each split in each tree, compute the improvement in the split-criterion (MSE for regression Gini for classification). Then average the improvement made by each variable across all the trees that the variable is used. The variables with the largest average decrease in the error metric are considered most important. Permutation: For each tree, the OOB sample is passed down the tree and the prediction accuracy is recorded. Then the values for each variable (one at a time) are randomly permuted and the accuracy is again computed. The decrease in accuracy as a result of this randomly “shaking up” of variable values is averaged over all the trees for each variable. The variables with the largest average decrease in accuracy are considered most important. To compute these variable importance measures with ranger, you must include the importance argument. Once you’ve identified the optimal parameter values from the grid search, you will want to re-run your model with these hyperparameter values. # re-run model with impurity-based variable importance rf_impurity &lt;- ranger( formula = Sale_Price ~ ., data = ames_train, num.trees = 500, mtry = 20, min.node.size = 3, sample.fraction = .80, splitrule = &quot;variance&quot;, importance = &#39;impurity&#39;, verbose = FALSE, seed = 123 ) # re-run model with permutation-based variable importance rf_permutation &lt;- ranger( formula = Sale_Price ~ ., data = ames_train, num.trees = 500, mtry = 20, min.node.size = 3, sample.fraction = .80, splitrule = &quot;variance&quot;, importance = &#39;permutation&#39;, verbose = FALSE, seed = 123 ) For both options, you can directly access the variable importance values with model_name$variable.importance. However, here we’ll plot the variable importance using the vip package. Typically, you will not see the same variable importance order between the two options; however, you will often see similar variables at the top of the plots. Consquently, in this example, we can comfortably state that there appears to be enough evidence to suggest that two variables stand out as most influential: Overall_Qual Gr_Liv_Area Looking at the next ~10 variables in both plots, you will also see some commonality in influential variables (i.e. Garage_Cars, Bsmt_Qual, Year_Built, Exter_Qual). p1 &lt;- vip(rf_impurity, num_features = 25, bar = FALSE) + ggtitle(&quot;Impurity-based variable importance&quot;) p2 &lt;- vip(rf_permutation, num_features = 25, bar = FALSE) + ggtitle(&quot;Permutation-based variable importance&quot;) gridExtra::grid.arrange(p1, p2, nrow = 1) Figure 9.8: Top 25 most important variables based on impurity (left) and permutation (right). To better understand the relationship between these important features and Sale_Price, we can create partial dependence plots (PDPs). If you recall in the linear and regularized regression sections, we saw that the linear model assumed a continously increasing relationship between Gr_Liv_Area and Sale_Price. In the MARS chapter, we saw as homes exceed 2,945 square feet, each additional square foot demands a higher marginal increase in sale price than homes with less than 2,945 square feet. However, in between the knots of a MARS model, the relationship will remain linear. However, the PDP plot below displays how random forest models can capture unique non-linear and non-monotonic relationships between predictors and the target. In this case, Sale_Price appears to not be influenced by Gr_Liv_Area values below 750 sqft or above 3500 sqft. This change in realtionship was not well captured by the prior parametric models. # partial dependence of Sale_Price on Gr_Liv_Area rf_impurity %&gt;% partial(pred.var = &quot;Gr_Liv_Area&quot;, grid.resolution = 50) %&gt;% autoplot(rug = TRUE, train = ames_train) Figure 9.9: The mean predicted sale price as the above ground living area increases. Additionally, if we assess the relationship between the Overall_Qual predictor and Sale_Price, we see a continual increase as the overall quality increases. This provides a more comprehensive understanding of the relationship than the results we saw in the regularized regression section (7.5). We see that the largest impact on Sale_Price occurs when houses go from “Good” overall quality to “Very Good”. # partial dependence of Sale_Price on Overall_Qual rf_impurity %&gt;% partial(pred.var = &quot;Overall_Qual&quot;, train = as.data.frame(ames_train)) %&gt;% autoplot() Figure 9.10: The mean predicted sale price for each level of the overall quality variable. Individual conditional expectation (ICE) curves (Goldstein et al. 2015) are an extension of PDP plots but, rather than plot the average marginal effect on the response variable, we plot the change in the predicted response variable for each observation as we vary each predictor variable. Below shows the regular ICE curve plot (left) and the centered ICE curves (right). When the curves have a wide range of intercepts and are consequently “stacked” on each other, heterogeneity in the response variable values due to marginal changes in the predictor variable of interest can be difficult to discern. The centered ICE can help draw these inferences out and can highlight any strong heterogeneity in our results. The plots below show that marginal changes in Gr_Liv_Area have a fairly homogenous effect on our response variable. As Gr_Liv_Area increases, the vast majority of observations show a similar increasing effect on the predicted Sale_Price value. The primary differences is in the magnitude of the increasing effect. However, in the centered ICE plot you see evidence of a few observations that display a different pattern. Some have a higher \\(\\hat y\\) value when Gr_Liv_Area is between 2500-4000 and some have a decreasing \\(\\hat y\\) as Gr_Liv_AreA increases. These results may be a sign of interaction effects and would be worth exploring more closely. # ice curves of Sale_Price on Gr_Liv_Area ice1 &lt;- rf_impurity %&gt;% partial(pred.var = &quot;Gr_Liv_Area&quot;, grid.resolution = 50, ice = TRUE) %&gt;% autoplot(rug = TRUE, train = ames_train, alpha = 0.1) + ggtitle(&quot;Non-centered ICE plot&quot;) ice2 &lt;- rf_impurity %&gt;% partial(pred.var = &quot;Gr_Liv_Area&quot;, grid.resolution = 50, ice = TRUE) %&gt;% autoplot(rug = TRUE, train = ames_train, alpha = 0.1, center = TRUE) + ggtitle(&quot;Centered ICE plot&quot;) gridExtra::grid.arrange(ice1, ice2, nrow = 1) Figure 9.11: Non-centered (left) and centered (right) individual conditional expectation curve plots illustrate how changes in above ground square footage influences predicted sale price for all observations. Both PDPs and ICE curves should be assessed for the most influential variables as they help to explain the underlying patterns in the data that the random forest model is picking up. 9.8 Attrition data With the Ames data, the random forest models obtained predictive accuracy that was close to our best MARS model, but how about the attrition data? The following performs a grid search across 48 hyperparameter combinations. # get attrition data df &lt;- rsample::attrition %&gt;% dplyr::mutate_if(is.ordered, factor, ordered = FALSE) # Create training (70%) and test (30%) sets for the rsample::attrition data. # Use set.seed for reproducibility set.seed(123) churn_split &lt;- initial_split(df, prop = .7, strata = &quot;Attrition&quot;) churn_train &lt;- training(churn_split) churn_test &lt;- testing(churn_split) # create a tuning grid hyper_grid &lt;- expand.grid( mtry = seq(3, 18, by = 3), min.node.size = seq(1, 10, by = 3), splitrule = c(&quot;gini&quot;, &quot;extratrees&quot;) ) # cross validated model tuned_rf &lt;- train( x = subset(churn_train, select = -Attrition), y = churn_train$Attrition, method = &quot;ranger&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10), tuneGrid = hyper_grid, num.trees = 500, seed = 123 ) # best model tuned_rf$bestTune ## mtry splitrule min.node.size ## 31 12 gini 10 # plot results ggplot(tuned_rf) Figure 9.12: Cross-validated accuracy rate for the 48 different hyperparameter combinations in our grid search. The optimal model uses mtry = 9, splitrule = gini, and min.node.size = 4, which obtained a 10-fold CV accuracy rate of 85.8%. Similar to the MARS model, the random forest model does not improve predictive accuracy over an above the regularized regression model. Min. 1st Qu. Median Mean 3rd Qu. Max. NA’s Logistic_model 0.8446602 0.8532981 0.8557692 0.8670209 0.8899914 0.8942308 0 Elastic_net 0.8269231 0.8661955 0.8743932 0.8749103 0.8899914 0.9313725 0 MARS_model 0.8039216 0.8474375 0.8647311 0.8650623 0.8810680 0.9313725 0 RF_model 0.8235294 0.8409961 0.8653846 0.8612044 0.8802113 0.9019608 0 9.9 Final thoughts Random forests provide a very powerful out-of-the-box algorithm that often has great predictive accuracy. Because of their more simplistic tuning nature and the fact that they require very little, if any, feature pre-processing they are often one of the first go-to algorithms when facing a predictive modeling problem. However, as we illustrated in this chapter, random forests are not guaranteed to improve predictive accuracy over and above linear models and their cousins. The following summarizes some of the advantages and disadvantages discussed regarding random forests modeling: TODO: may need to better tie in some of these advantages and disadvantages throughout the chapter. Advantages: Typically have very good performance. Remarkably good “out-of-the box” - very little tuning required. Built-in validation set - don’t need to sacrifice data for extra validation. Does not overfit. No data pre-processing required - often works great with categorical and numerical values as is. Robust to outliers. Handles missing data - imputation not required. Provide automatic feature selection. Disadvantages: Can become slow on large data sets. Although accurate, often cannot compete with the accuracy of advanced boosting algorithms. Less interpretable although this is easily addressed with various tools (variable importance, partial dependence plots, LIME, etc.). 9.10 Learning more The literature behind random forests are rich and we have only touched on the fundamentals. To learn more I would start with the following resources listed in order of complexity: An Introduction to Statistical Learning Applied Predictive Modeling Computer Age Statistical Inference The Elements of Statistical Learning References "]
]
