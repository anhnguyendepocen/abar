[
["linear-regression.html", "Chapter 5 Linear Regression 5.1 Prerequisites 5.2 Simple linear regression 5.3 Multiple linear regression 5.4 Assessing Model Accuracy 5.5 Model concerns 5.6 Principal component regression 5.7 Partial least squares 5.8 Feature Interpretation 5.9 Final thoughts 5.10 Learning more", " Chapter 5 Linear Regression Linear regression, a staple of statistical modeling from the precomputer age of statistics, is one of the simplest algorithms for supervised learning. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters, linear regression is still a useful and widely applied statistical learning method. Moreover, it serves as a good jumping-off point for newer approaches; as we will see in later chapters, many fancy statistical learning approaches can be seen as generalizations to or extensions of linear regression. Consequently, it is importance to have a good understanding of linear regression before studying more complex learning methods. This chapter introduces linear regression with an emphasis on predictiction, rather than inference. An excellent and comprehensive overview of linear regression is provided in Kutner et al. (2005). See Faraway (2016) for a discussion of linear regression in R (the book’s website also provides Python scripts). 5.1 Prerequisites In this chapter, we’ll make use of the following packages: library(caret) # for cross-validation and model training functions library(dplyr) # for data manipulation library(ggplot2) # for awesome graphics library(rsample) # for data splitting library(vip) # for variable importance plots library(modelr) To illustrate linear regression concepts, we’ll continue with the Ames housing data, where our intent is to predict Sale_Price (and log(Sale_Price)). As discussed in the Data splitting section 4.7.2, we’ll set aside part of our data for training and another part to assess generalizability error. # Construct train (70%) and test (30%) sets Ames housing data. ames &lt;- AmesHousing::make_ames() # Ames housing data set.seed(123) # for reproducibility ames_split &lt;- initial_split(ames, prop = 0.7, strata = &quot;Sale_Price&quot;) trn &lt;- training(ames_split) # training data tst &lt;- testing(ames_split) # test data 5.2 Simple linear regression In Section ?? we discussed the use of Pearson’s correlation coefficient to quantify the strength of the linear association between two continuous variables. In this section, we seek to fully characterize that linear relationship. Simple linear regression (SLR) assumes that the statistical relationship between two continuous variables is (at least approximately) linear: \\[\\begin{equation} \\tag{5.1} Y_i = \\beta_0 + \\beta_1 X_i + \\epsilon_i, \\quad \\text{for } i = 1, 2, \\dots, n, \\end{equation}\\] where \\(Y_i\\) represents the i-th response value, \\(X_i\\) represents the i-th feature value, \\(\\beta_0\\) and \\(\\beta_1\\) are fixed, but unknown constants (commonly referred to as coefficients or parameters) that represent the intercept and slope of the regression line, respectively, and \\(\\epsilon_i\\) represent noise or random error. In this Chapter, we’ll assume that the errors are normally distirbuted with mean zero and constant variance \\(\\sigma^2\\), denoted \\(\\stackrel{iid}{\\sim} \\left(0, \\sigma^2\\right)\\). Since the random errors are centered around zero (i.e., \\(E\\left(\\epsilon\\right) = 0\\)), linear regression is really a problem of estimating a conditional mean: \\[\\begin{equation} E\\left(Y_i | X_i\\right) = \\beta_0 + \\beta_1 X_i. \\end{equation}\\] For brevity, we often drop the conditional pice and write \\(E\\left(Y | X\\right) = E\\left(Y\\right)\\). Consequently, the interpretation of the coefficients are in terms of the average, or mean reponse. For example, the intercept \\(\\beta_0\\) represents the average response value when \\(X = 0\\) (it is often not meaningful or of interest and is is sometimes referred to as a bias term). The slope \\(\\beta_1\\) represents the increase in the average response per one-unit increase in \\(X\\) (i.e., it is a rate of change). 5.2.1 Estimation Ideally, we want estimates of \\(\\beta_0\\) and \\(\\beta_1\\) that give us the “best fitting” line. But what is meant by “best fitting”? The most common approach is to use the method of least squares (LS) estimation; this form of linear regression is often referred to ordinary least squares (OLS) regression. There are multiple ways to measure “best fitting”, but the LS criterion finds the “best fitting” line by minimizing the residual sum of squares (RSS): \\[\\begin{equation} \\tag{5.2} RSS\\left(\\beta_0, \\beta_1\\right) = \\sum_{i=1}^n\\left[Y_i - \\left(\\beta_0 + \\beta_1 X_i\\right)\\right]^2 = \\sum_{i=1}^n\\left(Y_i - \\beta_0 - \\beta_1 X_i\\right)^2. \\end{equation}\\] The LS estimated of \\(\\beta_0\\) and \\(\\beta_1\\) are denoted as \\(\\widehat{\\beta}_0\\) and \\(\\widehat{\\beta}_1\\), respectively. Once obtained, we can generate predicted values, say at \\(X = X_{new}\\), using the estimaed regression equation: \\[\\begin{equation} \\widehat{Y}_{new} = \\widehat{\\beta}_0 + \\widehat{\\beta}_1 X_{new}, \\end{equation}\\] where \\(\\widehat{Y}_{new} = \\widehat{E\\left(Y_{new} | X = X_{new}\\right)}\\) is the estimated mean response at \\(X = X_{new}\\). With the Ames housing data, suppose we wanted to model a linear relationship between the year the house was built (Year_Built) and sale price (Sale_Price). To perform an OLS regression model in R we can use the lm() function: model1 &lt;- lm(Sale_Price ~ Gr_Liv_Area, data = trn) The fitted model (model1) is displayed in the left plot in Figure 5.1 where the points represent the values of Sale_Price in the training data. In the right plot of Figure 5.1, the vertical lines represent the individual errors, called residuals, associated with each observation. The OLS criterion (??) identifies the “best fitting” line that minimizes the sum of squares of these residuals. Figure 5.1: The least squares fit from regressing Sale_Price on Gr_Liv_Area for the the Ames housing data. Left: Fitted regresison line. Right: Fitted regression line with vertical grey bars representing the residuals. The coef() function extracts the estimated coefficientes from the model. We can also use summary() to get a more detailed report of the model results. summary(model1) ## ## Call: ## lm(formula = Sale_Price ~ Gr_Liv_Area, data = trn) ## ## Residuals: ## Min 1Q Median 3Q Max ## -467327 -30799 -1432 22339 338467 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 17797.07 3916.11 4.545 0.00000582 *** ## Gr_Liv_Area 108.03 2.47 43.743 &lt; 0.0000000000000002 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 56850 on 2052 degrees of freedom ## Multiple R-squared: 0.4825, Adjusted R-squared: 0.4823 ## F-statistic: 1913 on 1 and 2052 DF, p-value: &lt; 0.00000000000000022 The estimated coefficients from our model are \\(\\widehat{\\beta}_0 =\\) 17797.07 and \\(\\widehat{\\beta}_1 =\\) 108.03. To interpret, we estimate that the mean selling price increases by 108.03 for each additional one square foot of above ground living space. This simple description of the relationship between the sale price and square footage using a single number (i.e., the slope) is what makes linear regression such an intuitive and popular modeling tool. One drawback of the LS procedure in linear regression is that it only provides estimates of the coefficents; it does not provide an estimate of the error variance \\(\\sigma^2\\)! Note that LS makes no assumptions about the random errors. These assumptions are important for inference and in estimating the error variance which we’re assuming is constant with a value of \\(\\sigma^2\\). One way to estimate \\(\\sigma^2\\) (which is required for characterizing the variability of our fitted model), is to use the method of maximum likelihood (ML) estimation (see (Kutner et al. 2005 sec 1.7) for details). The ML procedure requires that we assume a particular distribution for the random errors. Most often, we assume the errors to be normally distributed. In practice, under the usual assumptions stated above, an unbiased estimate of the error variance is given as the sum of the squared residuals divided by \\(n - p\\) (where \\(p\\) is the number of regression coefficients or parameters in the model): \\[\\begin{equation} \\widehat{\\sigma}^2 = \\frac{1}{n - p}\\sum_{i = 1} ^ n r_i ^ 2, \\end{equation}\\] where \\(r_i = \\left(Y_i - \\widehat{Y}_i\\right)\\) is referred to as the i-th residual (i.e., the difference between the i-th observed and predicted response value). The quantity \\(\\widehat{\\sigma}^2\\) is also referred to as the mean square error (MSE) and is often used for comparing regression models (typically, the MSEs are computed on a separate validation set or using cross-validation). It’s square root, denoted RMSE (for root mean square error) is also useful as it contains the same units as the response variable. In R, the RMSE of a linear model can be extracted using the sigma() function: sigma(model1) # RMSE ## [1] 56845.44 sigma(model1)^2 # MSE ## [1] 3231404480 Note that the RMSE is also reported as the Residual standard error in the output from summary(). 5.2.2 Inference How accurate are the LS of \\(\\beta_0\\) and \\(\\beta_1\\)? Point estimates by themselves are not very useful. It is often desirable to associate some measure of an estimates variability. The variability of an estimate is often measured by its standard error (SE)—the square root of its variance. If we assume that the errors in the linear regression model are \\(\\stackrel{iid}{\\sim} \\left(0, \\sigma^2\\right)\\), then simple expressions for the SEs of the estimated coefficients exist and are displayed in the column labeled Std. Error in the output from summary(). From this, we can also derive simple \\(t\\)-tests to understand if the individual coefficients are statistically significant from zero. The t-statistics for such a test are nothing more than the estimated coefficients divided by their corresponding estimated standard errors (i.e., in the output from summary(), t value = Estimate / Std. Error). The reported t-statistics measure the number of standard deviations each coefficient is away from 0. Thus, large t-statistics (greater than two in absolute value, say) roughly indicate statistical significance at the \\(\\alpha = 0.05\\) level. The p-values for these tests are also reported by summary() in the column labeled Pr(&gt;|t|). Under the same assumptions, we can also derive confidence intervals for the coefficients. The formula for the traditional \\(100\\left(1 - \\alpha\\right)\\)% confidence interval for \\(\\beta_j\\) is \\[\\begin{equation} \\widehat{\\beta}_j \\pm t_{1 - \\alpha / 2, n - p} \\widehat{SE}\\left(\\widehat{\\beta}_j\\right), \\tag{5.3} \\end{equation}\\] In R, we can construct such (one-at-a-time) confidence intervals for each coefficient using confint(). For example, a 95% confidence intervals for the coefficients in our SLR example can be computed using confint(model1, level = 0.95) ## 2.5 % 97.5 % ## (Intercept) 10117.107 25477.0385 ## Gr_Liv_Area 103.191 112.8779 To interpret, we estimate with 90% confidence that the mean selling price increases between 103.19 and 112.88 for each additional one square foot of above ground living space. We can also conclude that the slope \\(\\beta_1\\) is statistically significant from zero (or any other pre-specified value not included in the interval) at the \\(\\alpha = 0.05\\) level. This is also supported by the output from summary(). Most statistical software, including R, will include estimated standard errors, t-statistics, etc. as part of its regression output. However, it is important to remember that such quantities depend on three major assumptions of the linear regresion model: Independent observations The random errors have mean zero, and constant variance The random errors are normally distributed If any or all of these assumptions are violated, then remdial measures nned to be taken. For instance, weghted least squares (and other procedures) can be used the constant variance assumption is violated. Transformations (of both the response and features) can also help to correct departures from these assumptions. 5.3 Multiple linear regression 5.3.1 TODO: Qualitative variables/factors Interactions Residual analysis In practice, we often have more than one predictor. For example, with the Ames housing data, we may wish to understand if above ground square footage (Gr_Liv_Area) and the year the house was built (Year_Built) are (linearly) related to sales price (Sale_Price). We can extend the SLR model so that it can directly accommodate multiple predictors; this is referred to as a multiple linear regression (MLR) model. With two predictors, the MLR model becomes: \\[\\begin{equation} Y = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + \\epsilon, \\end{equation}\\] where \\(X_1\\) and \\(X_2\\) are features of interest. In our Ames housing exmple, \\(X_1\\) represents Gr_Liv_Area and \\(X_2\\) represents Year_Built. In R, multiple linear regression models can be fit by separating all the features of interest with a +: (model2 &lt;- lm(Sale_Price ~ Gr_Liv_Area + Year_Built, data = trn)) ## ## Call: ## lm(formula = Sale_Price ~ Gr_Liv_Area + Year_Built, data = trn) ## ## Coefficients: ## (Intercept) Gr_Liv_Area Year_Built ## -2121292.13 91.73 1097.66 Alternatively, we can use update() to update the model formula used in model. The new formula can use a . as short hand for keep everything on either the left or right hand side of the formula, and a + or - can be used to add or remove terms from the original model, respectively. In the case of adding Year_Built to to model1, we could’ve used: (model2 &lt;- update(model1, . ~ . + Year_Built)) ## ## Call: ## lm(formula = Sale_Price ~ Gr_Liv_Area + Year_Built, data = trn) ## ## Coefficients: ## (Intercept) Gr_Liv_Area Year_Built ## -2121292.13 91.73 1097.66 The LS estimates of the regression coefficients are \\(\\widehat{\\beta}_1 =\\) 91.728 and \\(\\widehat{\\beta}_2 =\\) 1097.664 (the estimated intercept is -2121292.13. In other words, every one square foot increase to above ground square footage is associated with an additional $91.73 in mean selling price when holding the year the house was built constant. Likewise, for every year newer a home is there is approximately an increase of $1,097.66 in selling price when holding the above ground square footage constant. A contour plot of the fitted regression surface is displayed in the left side of Figure 5.2 below. Note how the fitted regression surface is flat (i.e., it does not twist or bend). This is true for all linear models that include only main effects (i.e., terms involving only a single predictor). One way to model curvature is to include interaction effects. An interaction occurs when the effect of one predictor on the response depends on the values of other predictors. In linear regression, interactions are captured via products of features (i.e., \\(X1 \\times X_2\\)). A model with two main effects can also include a two-way interaction. For example, to include an interaction between \\(X_1 =\\) Gr_Liv_Area and \\(X_2 =\\) Year_Built, we would include an additional product term: \\[\\begin{equation} Y = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + \\beta_3 X_1 X_2 + \\epsilon. \\end{equation}\\] Note that in R, we use the : operator to include an interaction (techincally, we could use * as well, but x1 * x2 is shortcut for x1 + x2 + x1:x2 so is slightly redundant): lm(Sale_Price ~ Gr_Liv_Area + Year_Built + Gr_Liv_Area : Year_Built, data = trn) ## ## Call: ## lm(formula = Sale_Price ~ Gr_Liv_Area + Year_Built + Gr_Liv_Area:Year_Built, ## data = trn) ## ## Coefficients: ## (Intercept) Gr_Liv_Area Year_Built ## -719379.7373 -803.2844 386.1098 ## Gr_Liv_Area:Year_Built ## 0.4537 A contour plot of the fitted regression surface with interaction is displayed in the right side of Figure 5.2. Note the curvature in the contour lines. Interaction effects are quite prevelant in predictive modeling. Since linear models are an example of parametric modeling, it is up to the analyst to decide if and when to include interaction effects. In later chapters, we’ll discuss algorithms that can automatically detect and incoproarte interaction effects (albeit in different ways). It is also important to understand a concept called the hierachy principle—which demands that all lower-order terms corresponding to an interaction be retained in the model—when concidering interaction effects in linear regression models. Figure 5.2: In a three-dimensional setting, with two predictors and one response, the least squares regression line becomes a plane. The ‘best-fit’ plane minimizes the sum of squared errors between the actual sales price (individual dots) and the predicted sales price (plane). In general, we can include as many predicotrs as we want, as long as we have more rows than parmaters! The general multiple linear regression model with p distinct predictors is \\[\\begin{equation} Y = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + \\cdots + \\beta_p X_p + \\epsilon, \\end{equation}\\] where \\(X_i\\) for \\(i = 1, 2, \\dots, p\\) are the predictors of interest. Note some of these may represent interactions (e.g., \\(X_3 = X_1 \\times X_2\\)) between or transformations1 (e.g., \\(X_4 = \\sqrt{X_1}\\)) of the original features. Unfortunately, visualizing beyond three dimensions is not practical as our best-fit plane becomes a hyperplane. However, the motivation remains the same where the best-fit hyperplane is identified by minimizing the RSS. The below creates a third model where we use all features in our data set to predict Sale_Price. When fitting an MLR model in R with may terms, we can make use of the . notation for conveniance. For example, the dot in lm(Sale_Price ~ ., data = trn) is shorthand for regressing Sale_Price onto all other columns trn whereas lm(Sale_Price ~ .^2, data = trn) will regress Sale_Price on all other columns in trn while also including all possible two-way interactions effects. The use of . within lm() is illustrated below for the Ames housing example where we now include all possible main effects. model3 &lt;- lm(Sale_Price ~ ., data = trn) # include all possible main effects broom::tidy(model3) # print estimated coefficients in a tidy data frame ## # A tibble: 291 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -1.51e7 10738681. -1.41 0.159 ## 2 MS_SubClassOne_Story_1945_and_Old… 1.92e3 3619. 0.530 0.596 ## 3 MS_SubClassOne_Story_with_Finishe… 1.19e4 11239. 1.06 0.290 ## 4 MS_SubClassOne_and_Half_Story_Unf… 1.99e4 17296. 1.15 0.251 ## 5 MS_SubClassOne_and_Half_Story_Fin… 6.09e3 6270. 0.972 0.331 ## 6 MS_SubClassTwo_Story_1946_and_New… -2.99e2 5439. -0.0550 0.956 ## 7 MS_SubClassTwo_Story_1945_and_Old… 7.89e3 6075. 1.30 0.194 ## 8 MS_SubClassTwo_and_Half_Story_All… -1.90e4 10395. -1.82 0.0683 ## 9 MS_SubClassSplit_or_Multilevel -1.10e4 11925. -0.922 0.356 ## 10 MS_SubClassSplit_Foyer -8.82e3 7896. -1.12 0.264 ## # ... with 281 more rows 5.4 Assessing Model Accuracy We’ve fit three main effects models to the Ames housing data: a single predicor, two two predictors, and all possible predictors. But the question remains, which model is “best”? To answer this question we have to define what we mean by “best”. In our case, we’ll use the RMSE metric and cross-validation (Section 4.7.6) to determine the “best” model. We can use the caret::train() function to to train a linear model (i.e., method = &quot;lm&quot;) using cross-validation (or a variety of other validation methods). In practice, a number of factors should be considered in determining a “best” model (e.g., time constraints, model production cost, predictive accuracy, etc.). The benefit of caret is that it provides built-in cross-validation capabilities, whereas the lm() function does not2. The following code chunk uses caret::train() to refit model1 using 10-fold cross-validation: # Use caret package to train model using 10-fold cross-validation set.seed(123) # for reproducibility (cv_model1 &lt;- train( form = Sale_Price ~ Gr_Liv_Area, data = trn, method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10) )) ## Linear Regression ## ## 2054 samples ## 1 predictor ## ## No pre-processing ## Resampling: Cross-Validated (10 fold) ## Summary of sample sizes: 1849, 1849, 1849, 1848, 1849, 1849, ... ## Resampling results: ## ## RMSE Rsquared MAE ## 56872.53 0.488359 38678.32 ## ## Tuning parameter &#39;intercept&#39; was held constant at a value of TRUE The resulting cross-validated RMSE is $56,872.53 (this is the average RMSE across the 10 cross-validation folds). How should we interpret this? When applied to unseen data, the predictions this model makes are, on average, about $56,873 off from the actual sale price. We can perform cross validation on the other two models in a similar fashion, which we do in the code chunk below. # set.seed(123) cv_model2 &lt;- train( Sale_Price ~ Gr_Liv_Area + Year_Built, data = trn, method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10) ) # set.seed(123) cv_model3 &lt;- train( Sale_Price ~ ., data = trn, method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10) ) # Extract out of sample performance measures summary(resamples(list( model1 = cv_model1, model2 = cv_model2, model3 = cv_model3 ))) ## ## Call: ## summary.resamples(object = resamples(list(model1 = cv_model1, model2 ## = cv_model2, model3 = cv_model3))) ## ## Models: model1, model2, model3 ## Number of resamples: 10 ## ## MAE ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## model1 35890.22 36623.61 38444.68 38678.32 40566.07 41819.36 0 ## model2 29242.66 30263.41 31201.89 31400.67 31895.10 34505.50 0 ## model3 14944.20 15851.63 17626.49 17700.57 18883.13 21980.35 0 ## ## RMSE ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## model1 49534.21 53293.60 56878.36 56872.53 58485.32 66579.00 0 ## model2 39812.27 43131.99 46900.17 46886.43 49341.44 55657.04 0 ## model3 21304.89 24402.89 46474.70 41438.00 53957.79 63246.61 0 ## ## Rsquared ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## model1 0.3125667 0.3965549 0.5179845 0.4883590 0.5607495 0.6351056 0 ## model2 0.5059805 0.5995888 0.6663934 0.6491582 0.7090147 0.7415758 0 ## model3 0.5456242 0.6428724 0.7123521 0.7523838 0.9058276 0.9250331 0 Extracting the results for each model, we see that by adding more information via more predictors, we are able to improve the out-of-sample cross validation performance metrics. Specifically, our average prediction RMSE reduces from $46,886.43 (the model with two predictors) down to $41,438.00 (for our full model). In this case, the model with all possible main effects performs the “best” (comapred with the other two). 5.5 Model concerns As previously stated, linear regression has been a popular modeling tool due to the ease of interpreting the coefficients. However, linear regression makes several strong assumptions that are often violated as we include more predictors in our model. Violation of these assumptions can lead to flawed interpretation of the coefficients and prediction results. 1. Linear relationship: Linear regression assumes a linear relationship between the predictor and the response variable. When a linear relationship does not hold then the coefficient estimate makes a flawed assumption that a constant relationship holds. However, as discussed in Chapter 1.1, non-linear relationships can be made linear (or near-linear) by applying power transformations to the response and/or predictor. For example, Figure 5.3 illustrates the relationship between sale price and the year a home was built. The left plot illustrates the non-linear relationship that exists. However, we can achieve a near-linear relationship by log transforming sale price; although some non-linearity still exists for older homes. p1 &lt;- ggplot(trn, aes(Year_Built, Sale_Price)) + geom_point(size = 1, alpha = .4) + geom_smooth(se = FALSE) + scale_y_continuous(&quot;Sale price&quot;, labels = scales::dollar) + xlab(&quot;Year built&quot;) + ggtitle(&quot;Non-transformed variables with a \\nnon-linear relationship.&quot;) p2 &lt;- ggplot(trn, aes(Year_Built, Sale_Price)) + geom_point(size = 1, alpha = .4) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + scale_y_log10(&quot;Sale price&quot;, labels = scales::dollar, breaks = seq(0, 400000, by = 100000)) + xlab(&quot;Year built&quot;) + ggtitle(&quot;Transforming variables can provide a \\nnear-linear relationship.&quot;) gridExtra::grid.arrange(p1, p2, nrow = 1) Figure 5.3: Linear regression assumes a linear relationship between the predictor(s) and the response variable; however, non-linear relationships can often be altered to be near-linear by appying a transformation to the variable(s). 2. Constant variance among residuals: Linear regression assumes the variance among error terms (\\(\\epsilon_1, \\epsilon_2, ..., \\epsilon_p\\)) are constant (also referred to as homoscedasticity). When residuals are not constant, the p-values and confidence intervals of the coefficients are invalid resulting in invalid prediction estimates and confidence intervals. Similar to the linear relationships assumption, non-constant variance can often be resolved with variable transformations or by including additional predictors. For example, Figure 5.4 shows residuals across predicted values for our linear regression models model1 and model3. model1 displays a classic violation of constant variance with cone-shaped residuals. However, model3 appears to have near-constant variance. The broom::augment function is an easy way to add model results to each observation (i.e. predicted values, residuals). df1 &lt;- broom::augment(cv_model1$finalModel, data = trn) p1 &lt;- ggplot(df1, aes(.fitted, .resid)) + geom_point(size = 1, alpha = .4) + xlab(&quot;Predicted values&quot;) + ylab(&quot;Residuals&quot;) + ggtitle(&quot;Model 1&quot;, subtitle = &quot;Sale_Price ~ Gr_Liv_Area&quot;) df2 &lt;- broom::augment(cv_model3$finalModel, data = trn) p2 &lt;- ggplot(df2, aes(.fitted, .resid)) + geom_point(size = 1, alpha = .4) + xlab(&quot;Predicted values&quot;) + ylab(&quot;Residuals&quot;) + ggtitle(&quot;Model 3&quot;, subtitle = &quot;Sale_Price ~ .&quot;) gridExtra::grid.arrange(p1, p2, nrow = 1) Figure 5.4: Linear regression assumes constant variance among the residuals. model1 (left) shows definitive signs of heteroskedasticity whereas model3 (right) appears to have constant variance. 3. No autocorrelation: Linear regression assumes the error terms are also independent and uncorrelated. If in fact, there is correlation among the error terms, then the estimated standard errors of the coefficients will be biased leading to prediction intervals being narrower than they should be. For example, the left plot in Figure 5.5 displays the residuals (y-axis) to the observation ID (x-axis) for model1. A clear pattern exists suggesting that information about \\(\\epsilon_1\\) provides information about \\(\\epsilon_2\\). This pattern is a result of the data being ordered by neighborhood, which we have not accounted for in this model. Consequently, the residuals for homes in the same neighborhood are correlated (homes within a neighborhood are typically the same size and can often contain similar features). Since the Neighborhood predictor is included in model3 (right plot), our errors are no longer correlated. df1 &lt;- mutate(df1, id = row_number()) df2 &lt;- mutate(df2, id = row_number()) p1 &lt;- ggplot(df1, aes(id, .resid)) + geom_point(size = 1, alpha = .4) + xlab(&quot;Row ID&quot;) + ylab(&quot;Residuals&quot;) + ggtitle(&quot;Model 1&quot;, subtitle = &quot;Correlated residuals.&quot;) p2 &lt;- ggplot(df2, aes(id, .resid)) + geom_point(size = 1, alpha = .4) + xlab(&quot;Row ID&quot;) + ylab(&quot;Residuals&quot;) + ggtitle(&quot;Model 3&quot;, subtitle = &quot;Uncorrelated residuals.&quot;) gridExtra::grid.arrange(p1, p2, nrow = 1) Figure 5.5: Linear regression assumes uncorrelated errors. The residuals in model1 (left) have a distinct pattern suggesting that information about \\(\\epsilon_1\\) provides information about \\(\\epsilon_2\\). Whereas residuals in model3 have no signs of autocorrelation. 4. More observations than predictors: Although not an issue with the Ames housing data, when the number of features exceed the number of observations (\\(p &gt; n\\)), the OLS solution matrix is not invertible. This causes significant issues because it means the least-squares estimates are not unique. In fact, there are an infinite set of solutions available so we lose our ability to meaningfully interpret coefficients. Consequently, to resolve this issue an analyst can remove variables until \\(p &lt; n\\) and then fit an OLS regression model. Although an analyst can use pre-processing tools to guide this manual approach (Kuhn and Johnson 2013, 26:43–47), it can be cumbersome and prone to errors. Alternatively, we will introduce regularized regression in Chapter ?? which provides you an alternative linear regression technique when \\(p &gt; n\\). 5. No or little multicollinearity: Collinearity refers to the situation in which two or more predictor variables are closely related to one another. The presence of collinearity can pose problems in the regression context, since it can be difficult to separate out the individual effects of collinear variables on the response. In fact, collinearity can cause predictor variables to appear as statistically insignificant when in fact they are significant. This, obviously, leads to inaccurate interpretation of coefficients and identifying influential predictors. For example, in our data, Garage_Area and Garage_Cars are two variables that have a correlation of 0.89 and both variables are strongly correlated to our response variable (Sale_Price). Looking at our full model where both of these variables are included, we see that Garage_Area is found to be statistically significant but Garage_Cars is not. # fit with two strongly correlated variables summary(cv_model3) %&gt;% tidy() %&gt;% filter(term %in% c(&quot;Garage_Area&quot;, &quot;Garage_Cars&quot;)) ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Garage_Cars 2131. 1761. 1.21 0.226 ## 2 Garage_Area 19.5 5.88 3.31 0.000939 However, if we refit the full model without Garage_Area, the coefficient estimate for Garage_Cars increases three fold and becomes statistically significant. # model without Garage_Area set.seed(123) mod_wo_Garage_Area &lt;- train( Sale_Price ~ ., data = select(trn, -Garage_Area), method = &quot;lm&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10) ) summary(mod_wo_Garage_Area) %&gt;% tidy() %&gt;% filter(term == &quot;Garage_Cars&quot;) ## # A tibble: 1 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Garage_Cars 6342. 1222. 5.19 0.000000236 This reflects the instability in the linear regression model caused by the between-predictor relationships and this instability gets propagated directly to the model predictions. Considering 16 of our 34 numeric predictors have medium to strong correlation (Section 4.2), the biased coefficients of these predictors are likely restricting the predictive accuracy of our model. How can we control for this problem? One option is to manually remove one of the offending predictors. However, when the number of predictors is large such as in our case, this becomes difficult. Moreover, relationships between predictors can become complex and involve many predictors. In these cases, manual removal of specific predictors may not be possible. Consequently, the following sections offers two simple extensions of linear regression where dimension reduction is applied prior to performing linear regression. Chapter ?? offers a modified regression approach that helps to deal with the problem. And future chapters provide alternative methods that are not effected by multicollinearity. 5.6 Principal component regression As discussed in Chapter 4, principal components analysis can be used to represent correlated variables in a lower dimension and the resulting components can be used as predictors in the linear regression model. This two-step process is known as principal component regression (PCR) (Massy 1965). Performing PCR with caret is an easy extension from our previous model. We simply change the method to “pcr” within train to perform PCA on all our numeric predictors prior to applying the multiple regression. Often, we can greatly improve performance by only using a small subset of all principal components as predictors. Consequently, you can think of the number of principal components as a tuning parameter (see Section 4.7.5). The following performs cross validated PCR with \\(1, 2, \\dots, 20\\) principal components, and Figure 5.6 illustrates the cross-validated RMSE. You can see a significant drop in prediction error using just five principal components followed by a gradual decrease. Using 17 principal components provided the lowest RMSE of $35,769.99 (see cv_model_pcr for a comparison of the cross-validated results). Per Section (???)(pca), don’t forget to center and scale your predictors, which you can do by incorporating the preProcess argument. # perform 10-fold cross validation on a PCR model tuning the number of # principal components to use as predictors from 1-20 set.seed(123) cv_model_pcr &lt;- train( Sale_Price ~ ., data = trn, method = &quot;pcr&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10), preProcess = c(&quot;zv&quot;, &quot;center&quot;, &quot;scale&quot;), tuneLength = 20 ) # model with lowest RMSE cv_model_pcr$bestTune ## ncomp ## 17 17 # plot cross-validated RMSE plot(cv_model_pcr) Figure 5.6: The 10-fold cross valdation RMSE obtained using PCR with 1-20 principal components. By controlling for multicollinearity with PCR, we saw significant improvement in our predictive accuary (reducing out-of-sample RMSE from 41438 down to 35770). However, since PCR is a two step process, the PCA step does not consider any aspects of the response when it selects the components. Consequently, the new predictors produced by the PCA step are not designed to maximize the relationship with the response. Instead, it simply seeks to reduce the variability present throughout the predictor space. If that variability happens to be related to the response variability, then PCR has a good chance to identify a predictive relationship, as in our case. If, however, the variability in the predictor space is not related to the variability of the response, then PCR can have difficulty identifying a predictive relationship when one might actually exists (i.e. we may actually experience a decrease in our predictive accuracy). Thus, an alternative approach to reduce the impact of multicollinearity is partial least squares. 5.7 Partial least squares Partial least squares (PLS) can be viewed as a supervised dimension reduction procedure (Kuhn and Johnson 2013). Similar to PCR this technique also constructs a set of linear combinations of the inputs for regression, but unlike PCR it uses the response variable to aid the construction of the principal components. Thus, we can think of PLS as a supervised dimension reduction procedure that finds new features that not only appromxate the old features well, but also that are related to the response. TODO: IMAGE of PCR vs PLS Referring back to Equation (??), PLS will compute the first principal (\\(z_1\\)) by setting each \\(\\phi_{j1}\\) to the coefficient from a SLR model of \\(y\\) onto that respective \\(x_j\\). One can show that this coefficient is proportional to the correlation between \\(y\\) and \\(x_j\\). Hence, in computing \\(z_1 = \\sum^p_{j=1} \\phi_{j1}x_j\\), PLS places the highest weight on the variables that are most strongly related to the response. To compute the second principal (\\(z_2\\)), we first regress each variable on \\(z_1\\). The residuals from this regression captures the remaining signal that has not been explained by the first principal. We substitute these residual values for the predictor values in Equation (??). This process continues until all \\(m\\) components have been computed and then we use OLS to regress the response on \\(z_1, \\dots, z_m\\). See Friedman, Hastie, and Tibshirani (2001) and Geladi and Kowalski (1986) for a thorough discussion of PLS. Similar to PCR, we can easily fit a PLS model by changing the method argument in caret::train. As with PCR, the number of principal components to use is a tuning parameter that is determined by the model that maximize predictive accuracy (minimizes RMSE in this case). The following performs cross validated PLS with \\(1, 2, \\dots, 20\\) principal components, and Figure 5.7 illustrates the cross-validated RMSE. You can see a greater drop in prediction error than PCR. Using PLS with \\(m = 10\\) principal components provided the lowest RMSE of $31,522.47. # perform 10-fold cross validation on a PLS model tuning the number of # principal components to use as predictors from 1-20 set.seed(123) cv_model_pls &lt;- train( Sale_Price ~ ., data = trn, method = &quot;pls&quot;, trControl = trainControl(method = &quot;cv&quot;, number = 10), preProcess = c(&quot;zv&quot;, &quot;center&quot;, &quot;scale&quot;), tuneLength = 20 ) # model with lowest RMSE cv_model_pls$bestTune ## ncomp ## 10 10 # plot cross-validated RMSE plot(cv_model_pls) Figure 5.7: The 10-fold cross valdation RMSE obtained using PLS with 1-20 principal components. 5.8 Feature Interpretation Once we’ve found the model that minimizes the predictive accuracy, our next goal is to interpret the model structure. Linear regression models provide a very intuitive model structure as they assume a monotonic linear relationship between the predictor variables and the response. The linear relationship part of that statement just means, for a given predictor variable, it assumes for every one unit change in a given predictor variable there is a constant change in the response. As discussed earlier in the chapter, this constant change is provided by the given coefficient for a predictor. The monotonic relationship means that a given predictor variable will always have a positive or negative relationship. But how do we determine the most influential variables? Variable importance seeks to identify those variables that are most influential in our model. For linear regression models, this is most often measured by the absolute value of the t-statistic (Equation (??)) for each model parameter used. For a PLS model, variable importance is based on weighted sums of the absolute regression coefficients. The weights are a function of the reduction of the RSS across the number of PLS components and are computed separately for each outcome. Therefore, the contribution of the coefficients are weighted proportionally to the reduction in the RSS. We can use vip::vip to extract and plot the most important variables. The importance measure is normalized from 100 (most important) to 0 (least important). Figure 5.8 illustrates that the top 4 most important variables are Gr_liv_Area, First_Flr_SF, Garage_Area, and Garage_Cars respectively. vip(cv_model_pls, num_features = 20, method = &quot;model&quot;) Figure 5.8: Top 20 most important variables for the PLS model. As stated earlier, linear regression models assume a monotonic linear relationship. To illustrate this, we can apply partial dependence plots (PDPs). PDPs plot the change in the average predicted value (\\(\\hat y\\)) as specified feature(s) vary over their marginal distribution. As you will see in later chapters, PDPs become more useful when non-linear relationships are present. However, PDPs of linear models help illustrate how a fixed change in \\(x_i\\) relates to a fixed linear change in \\(\\hat y_i\\). The pdp package (Greenwell 2017) provides convenient functions for computing and plotting PDPs. For example, the following code chunk would plot the PDP for the Gr_Liv_Area predictor. pdp::partial(cv_model_pls, pred.var = “Gr_Liv_Area”, grid.resolution = 20) %&gt;% autoplot() All four of the most important predictors have a positive relationship with sale price; however, we see that the slope (\\(\\beta_i\\)) is steepest for the most important predictor and gradually decreases for lessor important variables. Figure 5.9: Partial dependence plots for the first four most important variables. 5.9 Final thoughts Linear regression is a great starting point in learning more advanced predictive analytic approaches because, in its simplest form, it is very intuitive and easy to interpret. Training a linear regression model is very easy and computationally efficient. However, due to the many assumptions required, the disadvantages of linear regression often outweigh their benefits. In our example, we saw how multicollinearity was interferring with predictive accuracy. By controlling multicollinearity with PCR and PLS we were able to improve predictive accuracy. Later chapters will build on the concepts illustrated in this chapter and will compare cross-validated performance results to identify the best predictive model. The following summarizes some of the advantages and disadvantages discussed regarding linear regression. FIXME: refine this section Advantages: Normal linear regression has no hyperparameters to tune and PCR and PLS have only one hyperparameter to tune; making these methods very simple to train. Computationally efficient - relatively fast compared to other algorithms in this book and does not require large memory. Easy to interpret results. Disadvantages: Makes strong asssumptions about the data. Does not handle missing data - must impute or remove observations with missing values. Not robust to outliers as they can still bias the coefficients. Assumes relationships between predictors and response variable to be monotonic linear (always increasing or decreasing in a linear fashion). Typically does not perform as well as more advanced methods that allow non-monotonic and non-linear relationships (i.e. random forests, gradient boosting machines, neural networks). Most large data sets violate one of the several assumptions made for linear regression to hold, which cause instability in the modeling results. 5.10 Learning more This will get you up and running with linear regression. Keep in mind that there is a lot more you can dig into so the following resources will help you learn more: An Introduction to Statistical Learning Applied Predictive Modeling Elements of Statistical Learning References "]
]
